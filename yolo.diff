diff --git a/Makefile b/Makefile
index 3d3d5e4..79ce6f7 100644
--- a/Makefile
+++ b/Makefile
@@ -16,9 +16,11 @@ VPATH=./src/
 EXEC=darknet
 OBJDIR=./obj/
 
-CC=gcc
+#CC=gcc -fopenmp
+CC=/opt/intel/bin/icc -fopenmp
 NVCC=nvcc 
 OPTS=-Ofast
+#OPTS=-O3
 LDFLAGS= -lm -pthread 
 COMMON= 
 CFLAGS=-Wall -Wfatal-errors 
@@ -48,6 +50,8 @@ CFLAGS+= -DCUDNN
 LDFLAGS+= -lcudnn
 endif
 
+CFLAGS+= -I/opt/intel/mklml_lnx_2017.0.1.20161005/include
+LDFLAGS+= -L/opt/intel/mklml_lnx_2017.0.1.20161005/lib -lmklml_intel -liomp5
 OBJ=gemm.o utils.o cuda.o convolutional_layer.o list.o image.o activations.o im2col.o col2im.o blas.o crop_layer.o dropout_layer.o maxpool_layer.o softmax_layer.o data.o matrix.o network.o connected_layer.o cost_layer.o parser.o option_list.o darknet.o detection_layer.o captcha.o route_layer.o writing.o box.o nightmare.o normalization_layer.o avgpool_layer.o coco.o dice.o yolo.o detector.o layer.o compare.o classifier.o local_layer.o swag.o shortcut_layer.o activation_layer.o rnn_layer.o gru_layer.o rnn.o rnn_vid.o crnn_layer.o demo.o tag.o cifar.o go.o batchnorm_layer.o art.o region_layer.o reorg_layer.o super.o voxel.o tree.o
 ifeq ($(GPU), 1) 
 LDFLAGS+= -lstdc++ 
diff --git a/src/activations.c b/src/activations.c
index 0cbb2f5..55d2692 100644
--- a/src/activations.c
+++ b/src/activations.c
@@ -92,13 +92,104 @@ float activate(float x, ACTIVATION a)
     return 0;
 }
 
+#if 1
+void activate_array(float *x, int n, ACTIVATION a)
+{
+    int i;
+    switch(a){
+        case LINEAR:
+#pragma omp parallel for num_threads(4)
+            for(i = 0; i < n; ++i){
+                x[i] = linear_activate(x[i]);
+            }
+            break;
+        case LOGISTIC:
+#pragma omp parallel for num_threads(4)
+            for(i = 0; i < n; ++i){
+                x[i] = logistic_activate(x[i]);
+            }
+            break;
+        case LOGGY:
+#pragma omp parallel for num_threads(4)
+            for(i = 0; i < n; ++i){
+                x[i] = loggy_activate(x[i]);
+            }
+            break;
+        case RELU:
+#pragma omp parallel for num_threads(4)
+            for(i = 0; i < n; ++i){
+                x[i] = relu_activate(x[i]);
+            }
+            break;
+        case ELU:
+#pragma omp parallel for num_threads(4)
+            for(i = 0; i < n; ++i){
+                x[i] = elu_activate(x[i]);
+            }
+            break;
+        case RELIE:
+#pragma omp parallel for num_threads(4)
+            for(i = 0; i < n; ++i){
+                x[i] = relie_activate(x[i]);
+            }
+            break;
+        case RAMP:
+#pragma omp parallel for num_threads(4)
+            for(i = 0; i < n; ++i){
+                x[i] = ramp_activate(x[i]);
+            }
+            break;
+        case LEAKY:
+#pragma omp parallel for num_threads(4)
+//#pragma omp simd
+            for(i = 0; i < n; ++i){
+                x[i] = leaky_activate(x[i]);
+            }
+            break;
+        case TANH:
+#pragma omp parallel for num_threads(4)
+            for(i = 0; i < n; ++i){
+                x[i] = tanh_activate(x[i]);
+            }
+            break;
+        case PLSE:
+#pragma omp parallel for num_threads(4)
+            for(i = 0; i < n; ++i){
+                x[i] = plse_activate(x[i]);
+            }
+            break;
+        case STAIR:
+#pragma omp parallel for num_threads(4)
+            for(i = 0; i < n; ++i){
+                x[i] = stair_activate(x[i]);
+            }
+            break;
+        case HARDTAN:
+#pragma omp parallel for num_threads(4)
+            for(i = 0; i < n; ++i){
+                x[i] = hardtan_activate(x[i]);
+            }
+            break;
+        case LHTAN:
+#pragma omp parallel for num_threads(4)
+            for(i = 0; i < n; ++i){
+                x[i] = lhtan_activate(x[i]);
+            }
+            break;
+    }
+}
+
+#else
 void activate_array(float *x, const int n, const ACTIVATION a)
 {
     int i;
+#pragma omp parallel for num_threads(4)
+#pragma omp simd
     for(i = 0; i < n; ++i){
         x[i] = activate(x[i], a);
     }
 }
+#endif
 
 float gradient(float x, ACTIVATION a)
 {
diff --git a/src/blas.c b/src/blas.c
index 31bd86b..831d006 100644
--- a/src/blas.c
+++ b/src/blas.c
@@ -115,8 +115,10 @@ void variance_cpu(float *x, float *mean, int batch, int filters, int spatial, fl
 void normalize_cpu(float *x, float *mean, float *variance, int batch, int filters, int spatial)
 {
     int b, f, i;
+#pragma omp parallel for num_threads(4)
     for(b = 0; b < batch; ++b){
         for(f = 0; f < filters; ++f){
+#pragma omp simd
             for(i = 0; i < spatial; ++i){
                 int index = b*filters*spatial + f*spatial + i;
                 x[index] = (x[index] - mean[f])/(sqrt(variance[f]) + .000001f);
@@ -151,8 +153,12 @@ void axpy_cpu(int N, float ALPHA, float *X, int INCX, float *Y, int INCY)
 
 void scal_cpu(int N, float ALPHA, float *X, int INCX)
 {
+#if 1
     int i;
     for(i = 0; i < N; ++i) X[i*INCX] *= ALPHA;
+#else
+    cblas_sscal(N, ALPHA, X, INCX);
+#endif
 }
 
 void fill_cpu(int N, float ALPHA, float *X, int INCX)
diff --git a/src/convolutional_layer.c b/src/convolutional_layer.c
index 37211ab..61a4e99 100644
--- a/src/convolutional_layer.c
+++ b/src/convolutional_layer.c
@@ -448,10 +448,23 @@ void forward_convolutional_layer(convolutional_layer l, network_state state)
     float *b = state.workspace;
     float *c = l.output;
 
+    //static long total1=0, total2=0;
     for(i = 0; i < l.batch; ++i){
+        //struct timeval time_start, time_middle, time_end;
+        //gettimeofday(&time_start, NULL);
         im2col_cpu(state.input, l.c, l.h, l.w, 
                 l.size, l.stride, l.pad, b);
+        //gettimeofday(&time_middle, NULL);
         gemm(0,0,m,n,k,1,a,k,b,n,1,c,n);
+        //gettimeofday(&time_end, NULL);
+        //long time_diff1 = (time_middle.tv_sec * 1000) + (time_middle.tv_usec / 1000)
+                        //-((time_start.tv_sec * 1000) + (time_start.tv_usec / 1000));
+        //long time_diff2 = (time_end.tv_sec * 1000) + (time_end.tv_usec / 1000)
+                        //-((time_middle.tv_sec * 1000) + (time_middle.tv_usec / 1000));
+        //total1+=time_diff1;
+        //total2+=time_diff2;
+        //printf("im2col %f, gemm %f\n", time_diff1/1000.0, time_diff2/1000.0);
+        //printf("total1 %f, total2 %f\n", total1/1000.0, total2/1000.0);
         c += n*m;
         state.input += l.c*l.h*l.w;
     }
diff --git a/src/detector.c b/src/detector.c
index 1416c05..5140c06 100644
--- a/src/detector.c
+++ b/src/detector.c
@@ -475,9 +475,20 @@ void test_detector(char *datacfg, char *cfgfile, char *weightfile, char *filenam
         for(j = 0; j < l.w*l.h*l.n; ++j) probs[j] = calloc(l.classes + 1, sizeof(float *));
 
         float *X = sized.data;
-        time=clock();
-        network_predict(net, X);
-        printf("%s: Predicted in %f seconds.\n", input, sec(clock()-time));
+        //time=clock();
+        struct timeval time2_start, time2_end;
+        //network_predict(net, X);
+        gettimeofday(&time2_start, NULL);
+        int i;
+        int iter=1;
+        for (i=0; i<iter;i++) {
+            network_predict(net, X);
+        }
+        gettimeofday(&time2_end, NULL);
+        long time2_diff = (time2_end.tv_sec * 1000) + (time2_end.tv_usec / 1000)
+                        -((time2_start.tv_sec * 1000) + (time2_start.tv_usec / 1000));
+        printf("%s: Predicted in %f seconds(get_time_of_day()).\n", input, time2_diff/iter/1000.0);
+        //printf("%s: Predicted in %f seconds.(clock())\n", input, sec(clock()-time)/10);
         get_region_boxes(l, 1, 1, thresh, probs, boxes, 0, 0, hier_thresh);
         if (l.softmax_tree && nms) do_nms_obj(boxes, probs, l.w*l.h*l.n, l.classes, nms);
         else if (nms) do_nms_sort(boxes, probs, l.w*l.h*l.n, l.classes, nms);
diff --git a/src/gemm.c b/src/gemm.c
index 3003be0..ddbe441 100644
--- a/src/gemm.c
+++ b/src/gemm.c
@@ -1,3 +1,4 @@
+#include <cblas.h>
 #include "gemm.h"
 #include "utils.h"
 #include "cuda.h"
@@ -62,13 +63,23 @@ void time_random_matrix(int TA, int TB, int m, int k, int n)
 }
 
 
+long long int total = 0;
+int count = 0;
 void gemm(int TA, int TB, int M, int N, int K, float ALPHA, 
         float *A, int lda, 
         float *B, int ldb,
         float BETA,
         float *C, int ldc)
 {
-    gemm_cpu( TA,  TB,  M, N, K, ALPHA,A,lda, B, ldb,BETA,C,ldc);
+    //gemm_cpu( TA,  TB,  M, N, K, ALPHA,A,lda, B, ldb,BETA,C,ldc);
+#if 0
+    total=total+M*N*(K*2-1);
+    count++;
+    if ((count % 1) == 0) {
+        printf ("total FLOPS = %lld\n", total);
+    }
+#endif
+    cblas_sgemm(CblasRowMajor, TA?CblasTrans:CblasNoTrans, TB?CblasTrans:CblasNoTrans, M, N, K, ALPHA, A, lda, B, ldb, BETA, C, ldc);
 }
 
 void gemm_nn(int M, int N, int K, float ALPHA, 
diff --git a/src/im2col.c b/src/im2col.c
index 69ec98a..ba26efc 100644
--- a/src/im2col.c
+++ b/src/im2col.c
@@ -1,6 +1,6 @@
 #include "im2col.h"
 #include <stdio.h>
-float im2col_get_pixel(float *im, int height, int width, int channels,
+static inline float im2col_get_pixel(float *im, int height, int width, int channels,
                         int row, int col, int channel, int pad)
 {
     row -= pad;
@@ -22,11 +22,14 @@ void im2col_cpu(float* data_im,
     int width_col = (width + 2*pad - ksize) / stride + 1;
 
     int channels_col = channels * ksize * ksize;
+#pragma omp parallel for num_threads(4)
     for (c = 0; c < channels_col; ++c) {
         int w_offset = c % ksize;
         int h_offset = (c / ksize) % ksize;
         int c_im = c / ksize / ksize;
+//#pragma omp simd
         for (h = 0; h < height_col; ++h) {
+#pragma omp simd
             for (w = 0; w < width_col; ++w) {
                 int im_row = h_offset + h * stride;
                 int im_col = w_offset + w * stride;
diff --git a/src/image.c b/src/image.c
index 5a90efd..58487ca 100644
--- a/src/image.c
+++ b/src/image.c
@@ -4,6 +4,7 @@
 #include "cuda.h"
 #include <stdio.h>
 #include <math.h>
+#include <sys/time.h>
 
 #define STB_IMAGE_IMPLEMENTATION
 #include "stb_image.h"
@@ -501,7 +502,20 @@ image load_image_cv(char *filename, int channels)
 
 image get_image_from_stream(CvCapture *cap)
 {
-    IplImage* src = cvQueryFrame(cap);
+    IplImage *src = NULL;
+#if 1
+    struct timeval start, end;
+// little trick to clear camera frame buffer before retrieving next frame.  Otherwise if the detection is slower than camera framerate, detection will be lagged
+    do {
+        gettimeofday(&start, NULL);
+        src = cvQueryFrame(cap);
+        gettimeofday(&end, NULL);
+        long diff = end.tv_sec *1000000 + end.tv_usec - (start.tv_sec *1000000 + start.tv_usec);
+        if (diff >= 5000) break;
+    } while (src);
+#else
+    src = cvQueryFrame(cap);
+#endif
     if (!src) return make_empty_image(0,0,0);
     image im = ipl_to_image(src);
     rgbgr_image(im);
diff --git a/src/maxpool_layer.c b/src/maxpool_layer.c
index 031d116..7fd0b15 100644
--- a/src/maxpool_layer.c
+++ b/src/maxpool_layer.c
@@ -87,6 +87,7 @@ void forward_maxpool_layer(const maxpool_layer l, network_state state)
     int c = l.c;
 
     for(b = 0; b < l.batch; ++b){
+#pragma omp parallel for
         for(k = 0; k < c; ++k){
             for(i = 0; i < h; ++i){
                 for(j = 0; j < w; ++j){
@@ -94,6 +95,7 @@ void forward_maxpool_layer(const maxpool_layer l, network_state state)
                     float max = -FLT_MAX;
                     int max_i = -1;
                     for(n = 0; n < l.size; ++n){
+#pragma omp simd
                         for(m = 0; m < l.size; ++m){
                             int cur_h = h_offset + i*l.stride + n;
                             int cur_w = w_offset + j*l.stride + m;
